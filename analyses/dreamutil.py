import git
import re
import os
from lxml import etree

from config import DATA_DIR


def get_file_changed(repo, sha1):
    changed_files = set()
    commit = repo.commit(sha1)
    parent = repo.commit(sha1 + '~')
    renamed_file = []
    for x in parent.diff(commit):
        if x.change_type == 'R':  # Renamed
            assert x.a_path != x.b_path
            renamed_file.append([x.a_path, x.b_path])
            continue

        assert x.a_path == x.b_path and x.change_type in ("A", "D", "M", "T")
        if x.a_path is not None:
            changed_files.add(x.a_path)
        if x.b_path is not None:
            changed_files.add(x.b_path)
    return list(changed_files), renamed_file


def _get_diff_line_num(diff):
    lines = diff.split("\n")
    at_index = len(lines)
    for i in range(len(lines)):
        if lines[i].startswith("@@ -"):
            assert i <= 7
            at_index = i
            break
    lines = lines[at_index:]

    parent_modify_lines = dict()
    this_modify_lines = dict()
    parent_line = 0
    this_line = 0
    line_pattern = r"@@ -(\d+)(,\d+)? \+(\d+)(,\d+)? @@"
    for line in lines:
        if line.startswith("@@ -"):
            result = re.search(line_pattern, line)
            parent_line = int(result.group(1)) - 1
            this_line = int(result.group(3)) - 1
        elif line.startswith("+"):
            this_line += 1
            if len(line[1:].strip()) > 0:  # only count non-empty changed line
                this_modify_lines[this_line] = line[1:].strip()
        elif line.startswith("-"):
            parent_line += 1
            if len(line[1:].strip()) > 0:
                parent_modify_lines[parent_line] = line[1:].strip()
        else:
            parent_line += 1
            this_line += 1
    return parent_modify_lines, this_modify_lines


def _get_function_line_scope(repo, sha1, file_name):
    function_line_scope = dict()
    try:
        file_content = repo.git.show(sha1 + ":" + file_name)
    except:  # file not in sha1
        print("Warning:", sha1, file_name, "not exist?!")
        return function_line_scope
    tmp_file_name = "%s_%s" % (sha1, file_name.replace("/", "_"))
    tmp_file_name = tmp_file_name.lower()
    with open(tmp_file_name, mode='w', encoding='utf-8', errors='ignore') as f:
        f.write(file_content)

    srcml_output = os.popen("srcml --position %s" % tmp_file_name)
    srcml_output = srcml_output.read()
    os.remove(tmp_file_name)

    root = etree.fromstring(srcml_output.encode('utf-8'))

    # end position of function definition generated by srcml may be wrong
    # some mistakes have been work around (i.e., partially corrected) in this script
    # e.g., do_tls_setsockopt_conf in https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/tls/tls_main.c?id=95fa145479fbc0a0c1fd3274ceb42ec03c042a4a
    # More references
    # https://github.com/srcML/srcML/issues/1697
    # https://github.com/srcML/srcML/issues/1700

    # function definition may also be omitted by srcml, i.e., incorrectly identified as macro
    # Oops... hard to deal with it
    # e.g., horrible_cidr_to_mask, init_peer are identified as macro in https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/net/wireguard/selftest/allowedips.c?id=e7096c131e5161fa3b8e52a650d7719d2857adfd

    last_func_name = None
    for func in root.xpath("//*[local-name() = 'function']"):
        func_name = func.xpath("./*[local-name() = 'name']/text()")[0]
        # POS_NS = 'http://www.srcML.org/srcML/position'
        # start = func.attrib[f'{{{POS_NS}}}start']
        # end = func.attrib[f'{{{POS_NS}}}end']
        start = func.xpath("./@*[local-name() = 'start']")[0]
        start_line_num = int(start.split(":")[0])
        end = func.xpath("./@*[local-name() = 'end']")[0]
        end_line_num = int(end.split(":")[0])

        block_content_end = func.xpath(
            "./*[local-name() = 'block']/*[local-name() = 'block_content']/@*[local-name() = 'end']")
        if block_content_end:
            end_line_num_by_block_content = int(block_content_end[0].split(":")[0]) + 1
            if end_line_num_by_block_content < end_line_num:
                end_line_num = end_line_num_by_block_content
                # print(func_name)
        else:
            block_end = func.xpath("./*[local-name() = 'block']/@*[local-name() = 'end']")
            if block_end:
                block_end_col = int(block_end[0].split(":")[1])
                if block_end_col == 0:
                    # block content is empty (without start and end) && block end col is 0 (incorrect indeed)
                    # => function end line num = block start line num
                    # FIXME: maybe it's better to determine the function range by locating the line num of "}"
                    block_start_line_num = \
                        func.xpath("./*[local-name() = 'block']/@*[local-name() = 'start']")[0].split(":")[0]
                    end_line_num_by_block = int(block_start_line_num)
                    if end_line_num_by_block < end_line_num:
                        end_line_num = end_line_num_by_block

        if last_func_name is not None:
            if function_line_scope[last_func_name][-1][1] > start_line_num:
                function_line_scope[last_func_name][-1][1] = start_line_num - 1
                # print(sha1, file_name, last_func_name, "->", function_line_scope[last_func_name][-1][1])

        if func_name not in function_line_scope:
            function_line_scope[func_name] = [[start_line_num, end_line_num]]
        else:
            function_line_scope[func_name].append([start_line_num, end_line_num])

        last_func_name = func_name
    return function_line_scope


def _get_function_changed_info(function_line_scope, line_changed):
    """
    :param function_line_scope: {function: [[start, end], ...], ...}
    :param line_changed: {line_number: line_content, ...}
    :return: {function: [(line_number, line_content), ...], ...}
    """
    function_changed_info = dict()

    # O(m*n), where m = # of functions, n = # of lines. just backup.
    # for line in line_changed:
    #     found_flag = False
    #     for func_name, scope_list in function_line_scope.items():
    #         for scope in scope_list:
    #             if scope[0] <= line <= scope[1]:
    #                 if func_name in function_changed_info:
    #                     function_changed_info[func_name].append(line)
    #                 else:
    #                     function_changed_info[func_name] = [line]
    #                 found_flag = True
    #         if found_flag:
    #             break

    func_list = []
    for func_name, scope_list in function_line_scope.items():
        for scope in scope_list:
            func_list.append([scope, func_name])

    line_list = sorted(line_changed.keys(), reverse=False)
    func_list = sorted(func_list, key=lambda x: x[0][0], reverse=False)

    i = 0
    j = 0
    line_len = len(line_list)
    func_len = len(func_list)
    while i < line_len and j < func_len:
        this_func_start = func_list[j][0][0]
        this_func_end = func_list[j][0][1]
        if this_func_start <= line_list[i] <= this_func_end:
            this_func_name = func_list[j][1]
            if this_func_name not in function_changed_info:
                function_changed_info[this_func_name] = [(line_list[i], line_changed[line_list[i]])]
            else:
                function_changed_info[this_func_name].append((line_list[i], line_changed[line_list[i]]))

            while i + 1 < line_len and line_list[i + 1] <= this_func_end:
                i += 1
                function_changed_info[this_func_name].append((line_list[i], line_changed[line_list[i]]))
            i += 1
            j += 1
        elif line_list[i] < this_func_start:
            i += 1
        else:
            j += 1
    return function_changed_info


def get_function_changed(repo, sha1, file_scope=None, language="C/C++", verbose=False):
    """
    :param repo: Repo object
    :param sha1: only support non-initial commit, otherwise runtime exception will be thrown
    :param file_scope: function changed in specific files (None or set)
    :param language: extract function changed in files related to the given language
    """
    if language != "C/C++":
        return "Language %s NOT Supported" % language

    src_suffix = {"C/C++": ('.c', '.cpp', '.cc', '.cxx', '.cp', '.C', '.CC', '.c++', '.C++', '.hpp', '.h', '.hh')}

    all_changed_files, all_renamed_files = get_file_changed(repo, sha1)
    if file_scope is None:
        changed_files = all_changed_files
        renamed_files = all_renamed_files
    else:
        assert type(file_scope) == set
        changed_files = list(file_scope.intersection(all_changed_files))
        renamed_files = []
        for [a_path, b_path] in all_renamed_files:
            if a_path in file_scope or b_path in file_scope:
                renamed_files.append([a_path, b_path])

    # Under Test: Improve the efficiency to handle numerous files
    # if len(changed_files) + len(renamed_files) > 800:
    #     print("Warning: %s modifies too many files(>800): %s." % (sha1, len(changed_files) + len(renamed_files)))
    #     return "Too Many Changed Files, Ignore All."

    changed_functions = set()
    changed_functions_with_line_info = {"Add": dict(), "Delete": dict()}
    for file in changed_files:
        if any(file.endswith(x) for x in src_suffix[language]):
            parent_modify_lines, this_modify_lines = _get_diff_line_num(repo.git.diff(sha1 + '~', sha1, '--', file))
            if parent_modify_lines:
                parent_sha1 = repo.commit(sha1 + "~").hexsha
                parent_function_scope = _get_function_line_scope(repo, parent_sha1, file)
                parent_function_changed_info = _get_function_changed_info(parent_function_scope, parent_modify_lines)
                for func, line_info in parent_function_changed_info.items():
                    changed_functions.add(func)
                    if file not in changed_functions_with_line_info["Delete"]:
                        changed_functions_with_line_info["Delete"][file] = {func: line_info}
                    else:
                        changed_functions_with_line_info["Delete"][file][func] = line_info

            if this_modify_lines:
                this_function_scope = _get_function_line_scope(repo, sha1, file)
                this_function_changed_info = _get_function_changed_info(this_function_scope, this_modify_lines)
                for func, line_info in this_function_changed_info.items():
                    changed_functions.add(func)
                    if file not in changed_functions_with_line_info["Add"]:
                        changed_functions_with_line_info["Add"][file] = {func: line_info}
                    else:
                        changed_functions_with_line_info["Add"][file][func] = line_info

    for [a_path, b_path] in renamed_files:
        if any(a_path.endswith(x) for x in src_suffix[language]) and \
                any(b_path.endswith(x) for x in src_suffix[language]):
            start_flag = "diff --git a/%s b/%s" % (a_path, b_path)
            all_diff_lines = repo.git.diff(sha1 + '~', sha1).split("\n")
            start_index = None
            end_index = None
            for i in range(len(all_diff_lines)):
                if start_index is not None and all_diff_lines[i].startswith("diff --git a"):
                    end_index = i
                    break
                elif start_flag == all_diff_lines[i]:
                    start_index = i

            assert start_index is not None

            if end_index:
                rename_related_diff_lines = all_diff_lines[start_index: end_index]
            else:
                rename_related_diff_lines = all_diff_lines[start_index:]

            rename_related_diff = ""
            for line in rename_related_diff_lines:
                rename_related_diff += line + "\n"

            parent_modify_lines, this_modify_lines = _get_diff_line_num(rename_related_diff)
            if parent_modify_lines:
                parent_sha1 = repo.commit(sha1 + "~").hexsha
                parent_function_scope = _get_function_line_scope(repo, parent_sha1, a_path)
                parent_function_changed_info = _get_function_changed_info(parent_function_scope, parent_modify_lines)
                for func, line_info in parent_function_changed_info.items():
                    changed_functions.add(func)
                    if a_path not in changed_functions_with_line_info["Delete"]:
                        changed_functions_with_line_info["Delete"][a_path] = {func: line_info}
                    else:
                        changed_functions_with_line_info["Delete"][a_path][func] = line_info

            if this_modify_lines:
                this_function_scope = _get_function_line_scope(repo, sha1, b_path)
                this_function_changed_info = _get_function_changed_info(this_function_scope, this_modify_lines)
                for func, line_info in this_function_changed_info.items():
                    changed_functions.add(func)
                    if b_path not in changed_functions_with_line_info["Add"]:
                        changed_functions_with_line_info["Add"][b_path] = {func: line_info}
                    else:
                        changed_functions_with_line_info["Add"][b_path][func] = line_info

    if verbose:
        return changed_functions_with_line_info
    else:
        return changed_functions


if __name__ == "__main__":
    test_repo = git.Repo(os.path.join(DATA_DIR, "linux"))
    print(get_function_changed(test_repo, "975ff7f3324af33e218e3d0abf5797c2b67f97d7", verbose=True))
